package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.57

import (
	"context"
	"time"

	"github.com/gelleson/changescout/changescout/internal/api/gql/generated"
	"github.com/gelleson/changescout/changescout/internal/api/gql/model"
	"github.com/gelleson/changescout/changescout/internal/domain"
	"github.com/gelleson/changescout/changescout/internal/infrastructure/database"
	"github.com/gelleson/changescout/changescout/internal/pkg/contexts"
	"github.com/gelleson/changescout/changescout/internal/platform/logger"
	"github.com/gelleson/changescout/changescout/internal/utils/transform"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

// CreateNotification is the resolver for the createNotification field.
func (r *mutationResolver) CreateNotification(ctx context.Context, input model.NotificationCreateInput) (*domain.Notification, error) {
	log := logger.FromContext(ctx)
	user, _ := contexts.UserContext(ctx)

	notification, err := r.NotificationService.Create(ctx, domain.Notification{
		Name:        input.Name,
		Type:        input.Type,
		UserID:      user.ID,
		WebsiteID:   input.WebsiteID,
		Token:       input.Token,
		Destination: input.Destination,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	})
	if err != nil {
		log.Error(
			"failed to create notification",
			zap.Error(err),
		)
		return nil, err
	}
	return &notification, nil
}

// UpdateNotification is the resolver for the updateNotification field.
func (r *mutationResolver) UpdateNotification(ctx context.Context, input model.NotificationUpdateInput) (*domain.Notification, error) {
	user, _ := contexts.UserContext(ctx)

	notification, err := r.NotificationService.Update(ctx, domain.Notification{
		ID:          input.ID,
		Name:        input.Name,
		Type:        input.Type,
		UserID:      user.ID,
		WebsiteID:   input.WebsiteID,
		Token:       input.Token,
		Destination: input.Destination,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	})
	if err != nil {
		return nil, err
	}
	return &notification, nil
}

// DeleteNotification is the resolver for the deleteNotification field.
func (r *mutationResolver) DeleteNotification(ctx context.Context, id uuid.UUID) (*domain.Notification, error) {
	site, err := r.NotificationService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	err = r.NotificationService.Delete(ctx, id)
	if err != nil {
		return nil, err
	}

	return &site, nil
}

// GetNotification is the resolver for the getNotification field.
func (r *queryResolver) GetNotification(ctx context.Context, id uuid.UUID) (*domain.Notification, error) {
	notification, err := r.NotificationService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	return &notification, nil
}

// GetNotifications is the resolver for the getNotifications field.
func (r *queryResolver) GetNotifications(ctx context.Context, input *model.NotificationFilters) ([]*domain.Notification, error) {
	user, _ := contexts.UserContext(ctx)

	filters := database.NotificationFilters{
		UserID: transform.ToPtr(user.ID),
	}
	if input != nil {
		if input.WebsiteID != nil {
			filters.WebsiteID = transform.ToPtr(*input.WebsiteID)
		}
		if input.FromDate != nil {
			filters.FromDate = transform.ToPtr(*input.FromDate)
		}
		if input.ToDate != nil {
			filters.ToDate = transform.ToPtr(*input.ToDate)
		}
	}

	notifications, _, err := r.NotificationService.List(ctx, filters, domain.Pagination{
		Limit:  100,
		Offset: 0,
	})
	if err != nil {
		return nil, err
	}

	return transform.MapObjects(notifications, transform.ToPtr), nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
